<?php
declare(strict_types=1);

namespace NoFlash\NSKeyedUnarchiver\Tests\NSKeyedUnarchiverTest;

use NoFlash\NSKeyedUnarchiver\DTO\Native\NSArray;
use NoFlash\NSKeyedUnarchiver\DTO\Native\NSDate;
use NoFlash\NSKeyedUnarchiver\DTO\Native\NSDictionary;
use NoFlash\NSKeyedUnarchiver\DTO\Native\NSObject;
use NoFlash\NSKeyedUnarchiver\DTO\Native\NSRegularExpression;
use NoFlash\NSKeyedUnarchiver\DTO\Native\NSSet;
use NoFlash\NSKeyedUnarchiver\DTO\Native\NSURL;
use NoFlash\NSKeyedUnarchiver\DTO\NSIncompleteObject;
use NoFlash\NSKeyedUnarchiver\NSKeyedUnarchiver;

/**
 * @group Functional
 * @covers \NoFlash\NSKeyedUnarchiver\NSKeyedUnarchiver
 *
 * This class tests both binary & textual plists. While technically we don't own the plist library, this is meant to be
 * an end-to-end functional test with real files. Testing archive decoding with unit tests is pointless as we don't own
 * the data format (nor docs are available).
 * This particular class is dedicated to testing decoding of various reference archives, as generated by the official
 * NSKeyedArchiver implementation.
 *
 * @testdox NSKeyedUnarchiver with reference archived data
 */
class NSKeyedUnarchiverTest_ArchivedData extends AbstractNSKeyedUnarchiverTest
{
    private const GENERATED_ROOT_CLASS = 'TestDummy';
    private const GENERATED_CHILD_CLASS = 'TestDummyExtended';

    /**
     * @dataProvider provideArchivedDataDecoder
     */
    public function testDecodesNullRootToArray(callable $unarchiveFn)
    {
        $sut = NSKeyedUnarchiver::createWithArrayCasting();
        $out = $unarchiveFn('null', $sut);

        $this->assertNull($out);
    }

    /**
     * @dataProvider provideArchivedDataDecoder
     */
    public function testDecodesNullRootToNativeObjects(callable $unarchiveFn)
    {
        $sut = NSKeyedUnarchiver::createWithNativeTypesCasting();
        $out = $unarchiveFn('null', $sut);

        $this->assertNull($out);
    }

    /**
     * @dataProvider provideArchivedDataDecoder
     */
    public function testDecodesEmptyObjectRootToArray(callable $unarchiveFn)
    {
        $sut = NSKeyedUnarchiver::createWithArrayCasting();
        $out = $unarchiveFn('emptyObject', $sut);

        $this->assertIsArray($out);
        $this->assertEmpty($out);
    }

    /**
     * @dataProvider provideArchivedDataDecoder
     */
    public function testDecodesEmptyObjectRootToNativeObjects(callable $unarchiveFn)
    {
        $sut = NSKeyedUnarchiver::createWithNativeTypesCasting();
        $out = $unarchiveFn('emptyObject', $sut);

        $this->assertInstanceOf(NSIncompleteObject::class, $out);
        $this->assertEmpty($out->toArray());
        $this->assertSame(self::GENERATED_ROOT_CLASS, $out->__NSNativeClass);
        $this->assertNull($out->__NSClassChain);
    }

    /**
     * @dataProvider provideArchivedDataDecoder
     */
    public function testDecodesEmptyChildObjectRootToArray(callable $unarchiveFn)
    {
        $sut = NSKeyedUnarchiver::createWithArrayCasting();
        $out = $unarchiveFn('emptyObjectExtended', $sut);

        $this->assertIsArray($out);
        $this->assertEmpty($out);
    }

    /**
     * @dataProvider provideArchivedDataDecoder
     */
    public function testDecodesEmptyChildObjectRootToNativeObjects(callable $unarchiveFn)
    {
        $sut = NSKeyedUnarchiver::createWithNativeTypesCasting();
        $out = $unarchiveFn('emptyObjectExtended', $sut);

        $this->assertInstanceOf(NSIncompleteObject::class, $out);
        $this->assertEmpty($out->toArray());
        $this->assertSame(self::GENERATED_CHILD_CLASS, $out->__NSNativeClass);
        $this->assertIsArray($out->__NSClassChain);
        $this->assertCount(3, $out->__NSClassChain);
        $this->assertSame(self::GENERATED_CHILD_CLASS, $out->__NSClassChain[0]);
        $this->assertStringContainsString(self::GENERATED_ROOT_CLASS, $out->__NSClassChain[1]);
        $this->assertSame(NSObject::NATIVE_CLASS, $out->__NSClassChain[2]);
    }

    /**
     * @dataProvider provideArchivedDataDecoder
     */
    public function testDecodesDateRootToArray(callable $unarchiveFn)
    {
        $sut = NSKeyedUnarchiver::createWithArrayCasting();
        $out = $unarchiveFn('date', $sut);

        $this->assertIsArray($out);
        //FYI: https://developer.apple.com/documentation/corefoundation/cfabsolutetime
        $this->assertSame(['NS.time' => 1210536312.0], $out);
    }

    /**
     * @dataProvider provideArchivedDataDecoder
     */
    public function testDecodesDateRootToNativeObjects(callable $unarchiveFn)
    {
        $sut = NSKeyedUnarchiver::createWithNativeTypesCasting();
        $out = $unarchiveFn('date', $sut);

        $this->assertInstanceOf(NSDate::class, $out);
        $this->assertEquals(new \DateTimeImmutable('2039-05-12 20:05:12.000000 UTC'), $out->dateTime);
    }

    //@TODO add UUID here!"UUIDv4": UUID(), => this requires hydrators to actually conditionally checkc for symfony UID

    /**
     * @dataProvider provideArchivedDataDecoder
     */
    public function testDecodesScalarTypesRootToArray(callable $unarchiveFn)
    {
        $sut = NSKeyedUnarchiver::createWithArrayCasting();
        $out = $unarchiveFn('scalarTypes', $sut);

        $this->assertDictionarySame([
            'typeFloat' => 3.14,
            'typeString' => 'foo bar',
            'data' => 'foobar',
            'typeInt' => 42,
            'typeBool' => true,
        ], $out);
    }

    /**
     * @dataProvider provideArchivedDataDecoder
     */
    public function testDecodesScalarTypesRootToNativeObjects(callable $unarchiveFn)
    {
        $sut = NSKeyedUnarchiver::createWithNativeTypesCasting();
        $out = $unarchiveFn('scalarTypes', $sut);

        $this->assertInstanceOf(NSIncompleteObject::class, $out);
        $this->assertDictionarySame([
            'typeFloat' => 3.14,
            'typeString' => 'foo bar',
            'data' => 'foobar',
            'typeInt' => 42,
            'typeBool' => true,
        ], $out->toArray());
    }

    /**
     * @dataProvider provideArchivedDataDecoder
     */
    public function testDecodesCollectionsRootToArray(callable $unarchiveFn)
    {
        $sut = NSKeyedUnarchiver::createWithArrayCasting();
        $out = $unarchiveFn('collections', $sut);

        $this->assertSame(['NS.objects' => ['foo', 'bar', 'baz']], $out['arrayOfStrings']);
        $this->assertSame(['NS.objects' => [1, 2, 3]], $out['arrayOfInts']);

        $this->assertArrayHasKey('NS.keys', $out['dictionary']);
        $this->assertArrayHasKey('NS.objects', $out['dictionary']);
        $this->assertDictionarySame(
            ['foo' => 'bar', 'baz' => 'aaa'],
            \array_combine($out['dictionary']['NS.keys'], $out['dictionary']['NS.objects'])
        );

        $this->assertEqualsCanonicalizing(['set', 'is', 'not', 'ordered'], $out['set']['NS.objects']);
    }

    /**
     * @dataProvider provideArchivedDataDecoder
     */
    public function testDecodesCollectionsRootToNativeObjects(callable $unarchiveFn)
    {
        $sut = NSKeyedUnarchiver::createWithNativeTypesCasting();
        $out = $unarchiveFn('collections', $sut);

        $this->assertInstanceOf(NSIncompleteObject::class, $out);

        $this->assertInstanceOf(NSArray::class, $out->arrayOfStrings);
        $this->assertSame(['foo', 'bar', 'baz'], \iterator_to_array($out->arrayOfStrings));

        $this->assertInstanceOf(NSArray::class, $out->arrayOfInts);
        $this->assertSame([1, 2, 3], \iterator_to_array($out->arrayOfInts));

        $this->assertInstanceOf(NSDictionary::class, $out->dictionary);
        $this->assertDictionarySame(['foo' => 'bar', 'baz' => 'aaa'], \iterator_to_array($out->dictionary));

        $this->assertInstanceOf(NSSet::class, $out->set);
        $this->assertEqualsCanonicalizing(['set', 'is', 'not', 'ordered'], $out->set->toArray());
    }

    /**
     * @dataProvider provideArchivedDataDecoder
     */
    public function testDecodesMiscTypesRootToArray(callable $unarchiveFn)
    {
        $sut = NSKeyedUnarchiver::createWithArrayCasting();
        $out = $unarchiveFn('miscTypes', $sut);

        $this->assertDictionarySame(
            ['NS.base' => null, 'NS.relative' => 'https://example.com/foo/bar?a=b#hash'],
            $out['url']
        );
        $this->assertDictionarySame(['NSPattern' => '(.*)', 'NSOptions' => 0], $out['regex']);
    }

    /**
     * @dataProvider provideArchivedDataDecoder
     */
    public function testDecodesMiscTypesRootToNativeObjects(callable $unarchiveFn)
    {
        $sut = NSKeyedUnarchiver::createWithNativeTypesCasting();
        $out = $unarchiveFn('miscTypes', $sut);

        $this->assertInstanceOf(NSIncompleteObject::class, $out);

        $this->assertInstanceOf(NSURL::class, $out->url);
        $this->assertNull($out->url->base);
        $this->assertSame('https://example.com/foo/bar?a=b#hash', $out->url->relative);

        $this->assertInstanceOf(NSRegularExpression::class, $out->regex);
        $this->assertSame('(.*)', $out->regex->pattern);
        $this->assertSame(0, $out->regex->options);
    }

    /**
     * @dataProvider provideArchivedDataDecoder
     */
    public function testDecodesDeeplyNestedRootToArray(callable $unarchiveFn)
    {
        $sut = NSKeyedUnarchiver::createWithArrayCasting();
        $out = $unarchiveFn('nested', $sut);

        $this->assertIsArray($out);

        //Level 0
        $this->assertArrayHasKey('NS.keys', $out);
        $this->assertArrayHasKey('NS.objects', $out);
        $outLevel0 = \array_combine($out['NS.keys'], $out['NS.objects']);
        $this->assertCount(3, $outLevel0);
        $this->assertSame(0, $outLevel0['level']);
        $this->assertSame(['NS.objects' => ['zero']], $outLevel0['levelPath']);

        //Level 1
        $this->assertArrayHasKey('levelZeroData', $outLevel0);
        $this->assertArrayHasKey('NS.keys', $outLevel0['levelZeroData']);
        $this->assertArrayHasKey('NS.objects', $outLevel0['levelZeroData']);
        $outLevel1 = \array_combine($outLevel0['levelZeroData']['NS.keys'], $outLevel0['levelZeroData']['NS.objects']);
        $this->assertCount(3, $outLevel1);
        $this->assertSame(1, $outLevel1['level']);
        $this->assertSame(['NS.objects' => ['zero', 'one']], $outLevel1['levelPath']);

        //Level 2
        $this->assertArrayHasKey('levelOneData', $outLevel1);
        $this->assertArrayHasKey('NS.keys', $outLevel1['levelOneData']);
        $this->assertArrayHasKey('NS.objects', $outLevel1['levelOneData']);
        $outLevel2 = \array_combine($outLevel1['levelOneData']['NS.keys'], $outLevel1['levelOneData']['NS.objects']);
        $this->assertCount(3, $outLevel2);
        $this->assertSame(2, $outLevel2['level']);
        $this->assertSame(['NS.objects' => ['zero', 'one', 'two']], $outLevel2['levelPath']);
        $this->assertDictionarySame(
            ['NS.base' => null, 'NS.relative' => 'https://example.com/foo/bar?a=b#hash'],
            $outLevel2['sampleUrl']
        );
    }

    /**
     * @dataProvider provideArchivedDataDecoder
     */
    public function testDecodesDeeplyNestedRootNativeObjects(callable $unarchiveFn)
    {
        $sut = NSKeyedUnarchiver::createWithNativeTypesCasting();
        $out = $unarchiveFn('nested', $sut);

        $this->assertInstanceOf(NSDictionary::class, $out);

        //Level 0
        $this->assertCount(3, $out);
        $this->assertSame(0, $out['level']);
        $this->assertInstanceOf(NSArray::class, $out['levelPath']);
        $this->assertSame(['zero'], \iterator_to_array($out['levelPath']));

        //Level 1
        $outLevel1 = $out['levelZeroData'];
        $this->assertCount(3, $outLevel1);
        $this->assertSame(1, $outLevel1['level']);
        $this->assertInstanceOf(NSArray::class, $outLevel1['levelPath']);
        $this->assertSame(['zero', 'one'], \iterator_to_array($outLevel1['levelPath']));

        //Level 2
        $outLevel2 = $outLevel1['levelOneData'];
        $this->assertCount(3, $outLevel2);
        $this->assertSame(2, $outLevel2['level']);
        $this->assertInstanceOf(NSArray::class, $outLevel2['levelPath']);
        $this->assertSame(['zero', 'one', 'two'], \iterator_to_array($outLevel2['levelPath']));
        $this->assertNull($outLevel2['sampleUrl']->base);
        $this->assertSame('https://example.com/foo/bar?a=b#hash', $outLevel2['sampleUrl']->relative);
    }

    /**
     * This test ensures that hydration to arrays is *NOT* preserving references. This is a behavior which is default to
     * the language (arrays are copied, not assigned by reference). Making them forcefully references will be very
     * counter-intuitive.
     *
     * @dataProvider provideArchivedDataDecoder
     */
    public function testDecodesReferencesToCopiesArray(callable $unarchiveFn)
    {
        $sut = NSKeyedUnarchiver::createWithArrayCasting();
        $out = $unarchiveFn('reference', $sut);

        $this->assertIsArray($out);
        $this->assertCount(2, $out['NS.objects']);
        $this->assertSame($out['NS.objects'][0], $out['NS.objects'][1], 'two copies should initially be the same');

        //Now we change one copy and see if other one changes as well (it should not)
        $out['NS.objects'][0]['NS.base'] = 'modified base';
        $out['NS.objects'][0]['NS.relative'] = 'modified relative';
        $this->assertNotSame($out['NS.objects'][0], $out['NS.objects'][1], 'second copy should not change with first');
    }

    /**
     * Unlike arrays in case of objects we want the same object to be referenced. While this is pretty rare in most
     * NSKeyedArchives, some applications use this extensively and hardly any unpackers outside the official ones
     * support this properly.
     *
     * @dataProvider provideArchivedDataDecoder
     */
    public function testDecodesReferencesToNativeObjectsReferencingTheSameInstance(callable $unarchiveFn)
    {
        $sut = NSKeyedUnarchiver::createWithNativeTypesCasting();
        $out = $unarchiveFn('reference', $sut);

        $this->assertInstanceOf(NSDictionary::class, $out);
        $this->assertCount(2, $out);
        $this->assertSame($out['copyOne'], $out['copyTwo'], 'Both entries should reference the same instance');
    }
}
